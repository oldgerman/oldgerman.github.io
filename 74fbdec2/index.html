<!DOCTYPE html>





<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">
  <meta name="google-site-verification" content="F_-gJswV8w9zL1mCRsfDqRogO9gml_HMXr_uLczMHcE">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="本篇是 SAU-G0 EEPROM 芯片应用笔记的随便记录版">
<meta name="keywords" content="stm32">
<meta property="og:type" content="article">
<meta property="og:title" content="SAU-G0 EEPROM笔记">
<meta property="og:url" content="http://oldgerman.github.io/74fbdec2/index.html">
<meta property="og:site_name" content="OldGerman&#39;s Blog">
<meta property="og:description" content="本篇是 SAU-G0 EEPROM 芯片应用笔记的随便记录版">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/STM32G0_Flash%E6%9E%84%E6%88%90.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/F4_FLASH%E7%9A%84Sector%E5%88%92%E5%88%86.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/G031%E6%93%A6%E5%86%99%E5%AF%BF%E5%91%BD.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C04-1024_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C08_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C16_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C04-1024_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/CAT24C_Page_Write_Sequence.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C512_Page_Write_Sequence.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C16_Dev_Addr.png">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/AT24C16_%E5%86%99%E5%88%86%E6%9E%901_%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.JPG">
<meta property="og:image" content="http://oldgerman.github.io/74fbdec2/union%E5%86%85%E5%B5%8C%E4%BD%8D%E5%9F%9F%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BAColum%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%9C%A8Debug%E4%B8%8B%E6%9F%A5%E7%9C%8B%E4%BD%8D%E5%9F%9F%E4%BF%AE%E6%94%B9%E6%83%85%E5%86%B5.png">
<meta property="og:updated_time" content="2024-04-15T02:13:11.449Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SAU-G0 EEPROM笔记">
<meta name="twitter:description" content="本篇是 SAU-G0 EEPROM 芯片应用笔记的随便记录版">
<meta name="twitter:image" content="http://oldgerman.github.io/74fbdec2/STM32G0_Flash%E6%9E%84%E6%88%90.png">
  <link rel="canonical" href="http://oldgerman.github.io/74fbdec2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>SAU-G0 EEPROM笔记 | OldGerman's Blog</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">OldGerman's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Focus on outdated electronic DIY</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-首页">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-分类">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-标签">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-归档">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-站点地图">
      
    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-wrapper">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oldgerman.github.io/74fbdec2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="过气德国佬">
      <meta itemprop="description" content="潮起潮落，云卷云舒">
      <meta itemprop="image" content="/images/OldGerman.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OldGerman's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">SAU-G0 EEPROM笔记

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-05-23 11:20:00" itemprop="dateCreated datePublished" datetime="2022-05-23T11:20:00+08:00">2022-05-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-15 10:13:11" itemprop="dateModified" datetime="2024-04-15T10:13:11+08:00">2024-04-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SAU-G0/" itemprop="url" rel="index"><span itemprop="name">SAU-G0</span></a></span>

                
                
              
            </span>
          

          
            <span id="/74fbdec2/" class="post-meta-item leancloud_visitors" data-flag-title="SAU-G0 EEPROM笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/74fbdec2/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/74fbdec2/" itemprop="commentCount"></span></a>
  </span>
  
  
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>23k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>21 分钟</span>
            </span>
          
            <div class="post-description">本篇是 SAU-G0 EEPROM 芯片应用笔记的随便记录版</div>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p><strong>为什么选择EEPROM？EEPROM与Flash有何不同？</strong></p><blockquote>
<p>既然STM32有那么大的Flash，为什么还要使用EEPROM？好问题，这得从几个方面来回答</p>
</blockquote><p><a href="https://github.com/oldgerman/SAU-G0" target="_blank" rel="noopener">SAU-G0</a> 是我学习STM32低功耗时做的传感器采集单元（就是个屑温湿度计罢了），使用STM32G031G8U6（之后简称G031）作为主控芯片，根据ST G0的中文手册，其Flash结构如下：</p><a id="more"></a>



<p><img src="/74fbdec2/STM32G0_Flash%E6%9E%84%E6%88%90.png" alt></p>
<p>其中G031存储器的64KB分为32页，每页2KB，最小擦除单位为1页</p>
<p>根据Flash的擦写特性，如果有一个1byte的数据变化需求，那它存储所在的页（或者扇区、或者最小擦除粒度）需要先整块擦除再写入，不能只修改该页的1个byte同时不影响该页原有的其他数据，那么原有的其他数据如果要保留怎么办，有两种方式：</p>
<ol>
<li>
<p>找一个空的页，将原有的有用数据的页整个复制过去，将原来的页擦除，将1byte的数据变化+复制过去的页复制到原来的flash，最后临时使用的这个空的页擦除。这个方法省MCU的内存，不需要在SRAM中存Flash页里的所有相关数据作为复制操作的缓冲区</p>
</li>
<li>
<p>在SRAM中总是存在一个flash修改页数据的全局变量，当该页发生一个1byte的数据变化需求，将该页的数据整个拷贝到SRAM中，擦除该页，再将1byte的数据变化+SRAM中的flash数据副本复制到原来的flash，这个方法耗费MCU的内存，需要在SRAM中存待修改的Flash页的所有相关数据，当页大小比较大时，比如STM32F4 Flash分布和G031不一样，在STM32F4的编程手册上可找到FLASH是按照Sector划分的：F4系列最小擦除粒度为扇区（最小的16K，但有16K、64K、128K三种大小）,那么当你修改的扇区中的有用数据有比如14K时，正好F4的SRAM剩余空间不够14KB，那么使用方式1，留一个16KB的扇区做复制备份，才是行得通的方法</p>
</li>
</ol>
<p><img src="/74fbdec2/F4_FLASH%E7%9A%84Sector%E5%88%92%E5%88%86.png" alt="F4_FLASH的Sector划分"></p>
<p>可见，如果需要频繁地修改非易失性存储器的数据，而且单次改动的数据量又很小，比如只占最小擦除粒度的 1/100，如果使用方式1，得磨损2次，如果使用方式2磨损1次，而且，STM32的Flash是有擦写寿命的，例如G031最坏情况只有1万次：</p>
<p><img src="/74fbdec2/G031%E6%93%A6%E5%86%99%E5%AF%BF%E5%91%BD.png" alt="6B509ED7C29973CE1FBBE74496ABB86B"></p>
<p>对于SAU-G0，若使用flash的一个2KB页每小时存一次采集数据，每天改动24次flash数据，那么416天后，G031的该页将面临报废（实际上2KB存不下这些采集数据hhh）</p>
<p>可能又有疑问，计算机的固态硬盘不也是Flash吗，每天面临比stm32还要多得多的擦写需求，那为啥没有那么容易报废？</p>
<p>好问题，因为固态硬盘除了存储介质是NAND Flash，每一块盘都带有闪存控制器，闪存翻译层的平均磨损逻辑，可以将擦除平均分布在所有的块上，最大化每个块的寿命，对于坏块自动屏蔽处理，从预留OP中开辟新的块来代替，而STM32是NOR Flash，没有（这么nb的）闪存主控，无法整这些高级骚操作，只能按照产品规格书的Flash最坏擦除寿命进行保守的应用</p>
<p>EEPROM最小擦写粒度是1byte，可以按1byte读写，也可以多个byte读写，不需要地址对齐，擦写寿命100万次，相比G031的 Flash，对于频繁的小容量数据存取EEPROM再合适不过</p>
<h2 id="eeprom参数表格at24cxx系列"><a class="markdownIt-Anchor" href="#eeprom参数表格at24cxx系列"></a> EEPROM参数表格（AT24Cxx系列）</h2>
<p>所有的这些型号都支持字节读写，即每个byte都有独立的地址，若地址指针寻址位数不够，使用I2C地址的P位来倍增地址指针寻址数量，例如1片24C16，I2C地址就占用0x50~0x57（nnd居然跟我用的PCF2129的0x51地址冲突了一个），还要注意发送的地址指针地址与同一I2C总线上的设备是否冲突，例如：<a href="https://www.cnblogs.com/xklzw/p/10521820.html" target="_blank" rel="noopener">X1226 和 AT24C16 地址冲突问题</a></p>
<table>
<thead>
<tr>
<th>EEPROM型号</th>
<th>容量</th>
<th>页大小</th>
<th>页数</th>
<th>发送地址位数</th>
<th>I2C地址结构</th>
<th>A<sub>(n)</sub>位数</th>
<th>P<sub>(n)</sub>位数</th>
<th>可寻址数</th>
<th>一条I2C总线最多<br>挂载同型号数量</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0180.pdf" target="_blank" rel="noopener">AT24C01</a></td>
<td>128 x 8 (1K)</td>
<td>8-byte page</td>
<td>16</td>
<td>8bit</td>
<td><img src="/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png" alt="AT24C01-02-32-64-128-256-512_Dev_Addr"></td>
<td>3</td>
<td>0</td>
<td>128</td>
<td>8</td>
</tr>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0180.pdf" target="_blank" rel="noopener">AT24C02</a></td>
<td>256 x 8 (2K)</td>
<td>8-byte page</td>
<td>32</td>
<td>8bit</td>
<td><img src="/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png" alt="AT24C01-02-32-64-128-256-512_Dev_Addr"></td>
<td>3</td>
<td>0</td>
<td>256</td>
<td>8</td>
</tr>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0180.pdf" target="_blank" rel="noopener">AT24C04</a></td>
<td>512 x 8 (4K)</td>
<td>16-byte page</td>
<td>32</td>
<td>8bit</td>
<td><img src="/74fbdec2/AT24C04-1024_Dev_Addr.png" alt="AT24C04-1024_Dev_Addr"></td>
<td>2</td>
<td>1</td>
<td>256 x 2<sup>1</sup></td>
<td>4</td>
</tr>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0180.pdf" target="_blank" rel="noopener">AT24C08</a></td>
<td>1,024 x 8 (8K)</td>
<td>16-byte page</td>
<td>64</td>
<td>8bit</td>
<td><img src="/74fbdec2/AT24C08_Dev_Addr.png" alt="AT24C08_Dev_Addr"></td>
<td>1</td>
<td>2</td>
<td>256 x 2<sup>2</sup></td>
<td>2</td>
</tr>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0180.pdf" target="_blank" rel="noopener">AT24C16</a></td>
<td>2,048 x 8 (16K)</td>
<td>16-byte page</td>
<td>128</td>
<td>8bit</td>
<td><img src="/74fbdec2/AT24C16_Dev_Addr.png" alt="AT24C16_Dev_Addr"></td>
<td>0</td>
<td>3</td>
<td>256 x 2<sup>3</sup></td>
<td>1</td>
</tr>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0336.pdf" target="_blank" rel="noopener">AT24C32</a></td>
<td>4,096 x 8 (32K)</td>
<td>32-byte page</td>
<td>128</td>
<td>16bit</td>
<td><img src="/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png" alt="AT24C01-02-32-64-128-256-512_Dev_Addr"></td>
<td>3</td>
<td>0</td>
<td>4096</td>
<td>8</td>
</tr>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0336.pdf" target="_blank" rel="noopener">AT24C64</a></td>
<td>8,192 x 8 (64K)</td>
<td>32-byte page</td>
<td>256</td>
<td>16bit</td>
<td><img src="/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png" alt="AT24C01-02-32-64-128-256-512_Dev_Addr"></td>
<td>3</td>
<td>0</td>
<td>8192</td>
<td>8</td>
</tr>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0670.pdf" target="_blank" rel="noopener">AT24C128</a></td>
<td>16,384 x 8 (128K)</td>
<td>64-byte page</td>
<td>256</td>
<td>16bit</td>
<td><img src="/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png" alt="AT24C01-02-32-64-128-256-512_Dev_Addr"></td>
<td>3</td>
<td>0</td>
<td>16384</td>
<td>8</td>
</tr>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0670.pdf" target="_blank" rel="noopener">AT24C256</a></td>
<td>32,768 x 8 (256K)</td>
<td>64-byte page</td>
<td>512</td>
<td>16bit</td>
<td><img src="/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png" alt="AT24C01-02-32-64-128-256-512_Dev_Addr"></td>
<td>3</td>
<td>0</td>
<td>32768</td>
<td>8</td>
</tr>
<tr>
<td><a href="http://ww1.microchip.com/downloads/en/devicedoc/doc1116.pdf" target="_blank" rel="noopener">AT24C512</a></td>
<td>65,536 x 8 (512K)</td>
<td>128-byte page</td>
<td>512</td>
<td>16bit</td>
<td><img src="/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png" alt="AT24C01-02-32-64-128-256-512_Dev_Addr"></td>
<td>3</td>
<td>0</td>
<td>65536</td>
<td>8</td>
</tr>
<tr>
<td><a href="http://ww1.microchip.com/downloads/en/devicedoc/doc1471.pdf" target="_blank" rel="noopener">AT24C1024</a></td>
<td>131,072 x 8 (1024K)</td>
<td>256-byte page</td>
<td>512</td>
<td>16bit</td>
<td><img src="/74fbdec2/AT24C04-1024_Dev_Addr.png" alt="AT24C04-1024_Dev_Addr"></td>
<td>2</td>
<td>1</td>
<td>65536 x 2<sup>1</sup></td>
<td>4</td>
</tr>
</tbody>
</table>
<p>P位的有无比较特殊：</p>
<ul>
<li>
<p>AT24C01 - AT24C02：没有P位</p>
</li>
<li>
<p>AT24C08 - AT24C16：有P位</p>
</li>
<li>
<p>AT24C32 - AT24C512：没有P位</p>
</li>
<li>
<p>AT24C1024：有1位P位，与AT24C04的I2C地址结构一样</p>
</li>
</ul>
<h2 id="ee24"><a class="markdownIt-Anchor" href="#ee24"></a> <a href="https://github.com/nimaltd/ee24" target="_blank" rel="noopener">ee24</a>（开源EEPROM驱动库 STM32 HAL）</h2>
<p>支持I2C EEPROM：24C01/02/04/08/16...到512</p>
<ul>
<li>
<p>不支持AT24C1024，因为AT24C1024地址有P0位，实际是17位寻址空间，而该库读写函数的第一个参数是uint16_t address，无法在不溢出的情况下接受17bit地址参数，无法检测bit[16]位而改变P0位，除非升级类型为uint32_t</p>
</li>
<li>
<p>后续文章EEPROM有关的代码大都是以此库的进行分析</p>
</li>
<li>
<p><a href="https://github.com/oldgerman/SAU-G0" target="_blank" rel="noopener">SAU-G0</a> 使用的 ee24 库是我魔改过的，<a href="https://github.com/oldgerman/SAU-G0/tree/master/SoftWare/SAU-G031G8U6/Libraries/ee24" target="_blank" rel="noopener">链接</a></p>
</li>
</ul>
<h2 id="eeprom擦除"><a class="markdownIt-Anchor" href="#eeprom擦除"></a> EEPROM擦除</h2>
<h3 id="一般擦除法"><a class="markdownIt-Anchor" href="#一般擦除法"></a> 一般擦除法</h3>
<p>ee24库在erasefull函数内创建了一个：256byte大小全为0xff的常量，多次写这个数据以达到擦除整片EEPROM</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ee24_eraseChip</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建擦除数据，元素值全为11111111，总大小等于24C02 的 256Byte</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> eraseData[<span class="number">32</span>] = &#123;</span><br><span class="line">            <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>,</span><br><span class="line">            <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>,</span><br><span class="line">            <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>,</span><br><span class="line">            <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//反复写它以达到全片擦除，写N次32组0xff</span></span><br><span class="line">    <span class="keyword">while</span> ( bytes &lt; (_EEPROM_SIZE_KBIT * <span class="number">256</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ee24_write(bytes, (<span class="keyword">uint8_t</span>*)eraseData, <span class="keyword">sizeof</span>(eraseData), <span class="number">100</span>) == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        bytes += <span class="keyword">sizeof</span>(eraseData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特殊擦除法"><a class="markdownIt-Anchor" href="#特殊擦除法"></a> 特殊擦除法</h3>
<p><a href="https://www.amobbs.com/thread-5687466-1-1.html" target="_blank" rel="noopener">EEPROM写入数据之前需要先进行擦除操作嘛（例如25LC512）？</a></p>
<p>对于Flash，在写入之前必须先擦除（也就是写入0xFF，因为Flash只能从1修改为0），对于EEPROM，写之前不需要擦除的，可以直接写入数据，支持按字节或页写</p>
<p><a href="http://ww1.microchip.com/downloads/en/devicedoc/21754m.pdf" target="_blank" rel="noopener">Microchip - 25LC512</a> 比较特殊，是SPI EEPROM，支持<strong>擦除指令</strong>，这里的擦除并非类似于Flash的写操作，手册（2.8 PAGE ERASE、2.9 SECTOR ERASE、2.10 CHIP ERASE）</p>
<h2 id="eeprom页大小"><a class="markdownIt-Anchor" href="#eeprom页大小"></a> EEPROM页大小</h2>
<p>比如 <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0180.pdf" target="_blank" rel="noopener">ATMEL - AT24C01A/02/04/08/16Kb</a> ，不同容量的页大小不同</p>
<blockquote>
<p><span style="color:rgb(255, 175, 200);">8-byte Page</span> (1K, 2K), <span style="color:rgb(255, 175, 200);">16-byte Page</span> (4K, 8K, 16K) Write Modes</p>
</blockquote>
<p>也有另类，比如 <a href="https://www.onsemi.com/pdf/datasheet/cat24c01-d.pdf" target="_blank" rel="noopener">安森美 - CAT24C01 - 2/4/8/16 Kb</a>中的2Kbit款也是16-byte-Page，而上面的AT24C01和AT24C02是16-byte-Page</p>
<blockquote>
<p>The CAT24C02/04/08/16 are 2−Kb, 4−Kb, 8−Kb and 16−Kb respectively I2C Serial EEPROM devices organized internally as 16/32/64 and 128 pages respectively of <span style="color:rgb(255, 175, 200);">16 bytes each</span></p>
</blockquote>
<p><a href="https://github.com/nimaltd/ee24" target="_blank" rel="noopener">ee24库</a>根据宏定义的EEPROM容量，自动选择页大小，与ATMEL - AT24Cxx的变化一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ee24Config.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>        _EEPROM_SIZE_KBIT     2    <span class="comment">//eeprom容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ee24.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (_EEPROM_SIZE_KBIT == 1) || (_EEPROM_SIZE_KBIT == 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EEPROM_PSIZE     8        <span class="comment">//eeprom page大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (_EEPROM_SIZE_KBIT == 4) || (_EEPROM_SIZE_KBIT == 8) || (_EEPROM_SIZE_KBIT == 16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EEPROM_PSIZE     16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EEPROM_PSIZE     32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>但对于  安森美 - CAT24C02 是16-byte-Page特殊情况，并不是说选 <code>_EEPROM_SIZE_KBIT 为 2</code>而配置 <code>_EEPROM_PSIZE 为  8    </code> ，8-byte Page Write Mode 就不适用了，而是通信次数会多一倍，以等价于16-byte-Page的写入数据量，宏这里这么搞是因为越大容量的EEPROM在一个读写时支持的字节数更多，可以减少通信初始化I2C的次数，那么如果对 24C02以 <code>_EEPROM_PSIZE  为   32</code> 读写会发生什么？根据手册PAGE WRITE部分的节选，数据地址会回到开头覆盖原来的数据：</p>
<blockquote>
<p>&quot;When the word address, internally generated, reaches the page boundary, the following byte is placed at the beginning of the same page. If more than eight (1K/2K) or sixteen (4K, 8K, 16K) data words are transmitted to the EEPROM, the data word address will “roll over” and previous data will be overwritten.&quot;</p>
<p>当内部生成的字地址到达页边界时，下一个字节被放置在同一页的开头。如果超过八个 (1K/2K) 或十六个 (4K, 8K, 16K) 数据字被传输到 EEPROM，数据字地址将“翻转”并且之前的数据将被覆盖。
这个是页覆盖特性</p>
</blockquote>
<h2 id="eeprom寻址"><a class="markdownIt-Anchor" href="#eeprom寻址"></a> EEPROM寻址</h2>
<p>以下是安森美 - CAT24C的页写模式序列图，每次I2C地址应答后，下一个从Master发来的8bit数据改变地址指针的位置</p>
<p><img src="/74fbdec2/CAT24C_Page_Write_Sequence.png" alt></p>
<p>EEPROM的地址指针从0x00开始寻址， 容量 2/4/8/16Kbit 的EEPROM的Address Byte只需要 1Byte，而I2C EEPROM最大有1024Kbit，8bit寻址能寻多大容量的EEPROM？比如<a href="https://item.szlcsc.com/232737.html" target="_blank" rel="noopener">FMD(辉芒微) FT24C16A-ELR-T</a>，可以简单计算一下，容量16Kbit就是2048Byte，每页16byte，需要128个地址，也就是7bit寻址，那么<a href="http://ww1.microchip.com/downloads/en/devicedoc/doc1116.pdf" target="_blank" rel="noopener">ATMEL - AT24C512T</a>呢？以下是手册节选：有512页，就是9bit寻址</p>
<blockquote>
<p>The 512K is internally organized as 512 pages of 128-bytes each. Random word addressing requires a 16-bit data word address.</p>
</blockquote>
<p>它的页写模式序列图如下，可见每次I2C地址应答后，后面两个从Master发来的8bit数据 改变 16bit地址 指针的位置</p>
<p><img src="/74fbdec2/AT24C512_Page_Write_Sequence.png" alt></p>
<p>回来看看ee24库，读写函数第一个参数是EPPROM内部寻址地址，接受16bit参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ee24_write</span><span class="params">(<span class="keyword">uint16_t</span> address, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ee24_read</span><span class="params">(<span class="keyword">uint16_t</span> address, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>读写函数体内部是多次while的形式，C预处理器根据EEPROM的页大小，计算出每次while的地址指针增量，即传入HAL_I2C_Mem_Read的MemAddSize参数，非常优雅，比如ee24_write：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ee24_write</span><span class="params">(<span class="keyword">uint16_t</span> address, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> timeout)</span></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        w = _EEPROM_PSIZE - (address  % _EEPROM_PSIZE);</span><br><span class="line">        <span class="keyword">if</span> (w &gt; len)</span><br><span class="line">            w = len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ((_EEPROM_SIZE_KBIT==1) || (_EEPROM_SIZE_KBIT==2))</span></span><br><span class="line">        <span class="keyword">if</span> (HAL_I2C_Mem_Write(&amp;_EEPROM_I2C, _EEPROM_ADDRESS, address, I2C_MEMADD_SIZE_8BIT, data, w, <span class="number">100</span>) == HAL_OK)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (_EEPROM_SIZE_KBIT==4)</span></span><br><span class="line">        <span class="keyword">if</span> (HAL_I2C_Mem_Write(&amp;_EEPROM_I2C, _EEPROM_ADDRESS | ((address &amp; <span class="number">0x0100</span>) &gt;&gt; <span class="number">7</span>), (address &amp; <span class="number">0xff</span>), I2C_MEMADD_SIZE_8BIT, data, w, <span class="number">100</span>) == HAL_OK)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (_EEPROM_SIZE_KBIT==8)</span></span><br><span class="line">        <span class="keyword">if</span> (HAL_I2C_Mem_Write(&amp;_EEPROM_I2C, _EEPROM_ADDRESS | ((address &amp; <span class="number">0x0300</span>) &gt;&gt; <span class="number">7</span>), (address &amp; <span class="number">0xff</span>), I2C_MEMADD_SIZE_8BIT, data, w, <span class="number">100</span>) == HAL_OK)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (_EEPROM_SIZE_KBIT==16)</span></span><br><span class="line">        <span class="keyword">if</span> (HAL_I2C_Mem_Write(&amp;_EEPROM_I2C, _EEPROM_ADDRESS | ((address &amp; <span class="number">0x0700</span>) &gt;&gt; <span class="number">7</span>), (address &amp; <span class="number">0xff</span>), I2C_MEMADD_SIZE_8BIT, data, w, <span class="number">100</span>) == HAL_OK)        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (HAL_I2C_Mem_Write(&amp;_EEPROM_I2C, _EEPROM_ADDRESS, address, I2C_MEMADD_SIZE_16BIT, data, w, <span class="number">100</span>) == HAL_OK)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            ee24_delay(<span class="number">10</span>);</span><br><span class="line">            len -= w;</span><br><span class="line">            data += w;</span><br><span class="line">            address += w;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">     &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析为at24c02的情况"><a class="markdownIt-Anchor" href="#分析为at24c02的情况"></a> 分析为AT24C02的情况：</h4>
<table>
<thead>
<tr>
<th>EEPROM型号</th>
<th>容量</th>
<th>页大小</th>
<th>页数</th>
<th>发送地址位数</th>
<th>I2C地址结构</th>
<th>A<sub>(n)</sub>位数</th>
<th>P<sub>(n)</sub>位数</th>
<th>可寻址数</th>
<th>一条I2C总线最多<br>挂载同型号数量</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0180.pdf" target="_blank" rel="noopener">AT24C02</a></td>
<td>256 x 8 (2K)</td>
<td>8-byte page</td>
<td>32</td>
<td>8bit</td>
<td><img src="/74fbdec2/AT24C01-02-32-64-128-256-512_Dev_Addr.png" alt="AT24C01-02-32-64-128-256-512_Dev_Addr"></td>
<td>3</td>
<td>0</td>
<td>256</td>
<td>8</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    w = _EEPROM_PSIZE - (address  % _EEPROM_PSIZE);</span><br><span class="line">    <span class="keyword">if</span> (w &gt; len)</span><br><span class="line">        w = len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ((_EEPROM_SIZE_KBIT==1) || (_EEPROM_SIZE_KBIT==2))</span></span><br><span class="line">    <span class="keyword">if</span> (HAL_I2C_Mem_Write(&amp;_EEPROM_I2C, _EEPROM_ADDRESS, address, I2C_MEMADD_SIZE_8BIT, data, w, <span class="number">100</span>) == HAL_OK)</span><br><span class="line">......</span><br><span class="line">    &#123;</span><br><span class="line">        ee24_delay(<span class="number">10</span>);</span><br><span class="line">        len -= w;</span><br><span class="line">        data += w;</span><br><span class="line">        address += w;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            ee24_lock = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相关宏和函数位置：</span></span><br><span class="line"><span class="comment">//stm32xxxx_hal_i2c.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_MEMADD_SIZE_8BIT            (0x00000001U)</span></span><br><span class="line"><span class="comment">//stm32xxxx_hal_i2c.c</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_I2C_Mem_Write</span><span class="params">(I2C_HandleTypeDef *hi2c, <span class="keyword">uint16_t</span> DevAddress, <span class="keyword">uint16_t</span> MemAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">uint16_t</span> MemAddSize, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size, <span class="keyword">uint32_t</span> Timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>根据<a href="#AT24Cxx%E7%B3%BB%E5%88%97%E5%8F%82%E6%95%B0%E8%A1%A8%E6%A0%BC">AT24Cxx系列参数表格</a>，AT24C02为 8-byte-page，发送地址为8bit，片内子地址寻址（地址指针）可对内部 256 Bytes中的任一个进行读/写操作，其寻址范围为00~FF，共256个寻址单位</p>
<p><a href="https://www.cnblogs.com/schips/p/at24cxx.html" target="_blank" rel="noopener">AT24C02、04、08、16 操作说明 </a></p>
<blockquote>
<p>1010是固定的，A表示器件地址，可以拉高和拉低，I2C总线上可以并接2的n次方个器件。P表示具体的内部地址数，比如at24c02共有256个字节，第二个地址字节完全可以满足，不用P。但是at24c04一个有512个字节，需要9位地址线，第一个字节中的p就表示地址线了，p=0表示低256字节，1表示高256字节。</p>
</blockquote>
<p>那么HAL_I2C_Mem_Read的MemAddSize参数传入I2C_MEMADD_SIZE_8BIT没有问题，那么参数<code>_EEPROM_SIZE_KBIT = 2</code>、<code>_EEPROM_PSIZE = 8</code> （8-byte-page），模拟一下写入过程，比如从EEPROM第一个页开始写，即<code>address  = 0</code>，需要写入1byte的数据长度 <code>len = 13</code>，由<code>array[13]</code>存储</p>
<table>
<thead>
<tr>
<th>循环次数</th>
<th>w</th>
<th>address</th>
<th>data</th>
<th>len</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8</td>
<td>0</td>
<td>&amp;array[0]</td>
<td>13</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>8</td>
<td>&amp;array[8]</td>
<td>5</td>
</tr>
</tbody>
</table>
<h4 id="分析为at24c16的情况"><a class="markdownIt-Anchor" href="#分析为at24c16的情况"></a> 分析为AT24C16的情况：</h4>
<table>
<thead>
<tr>
<th>EEPROM型号</th>
<th>容量</th>
<th>页大小</th>
<th>页数</th>
<th>发送地址位数</th>
<th>I2C地址结构</th>
<th>A<sub>(n)</sub>位数</th>
<th>P<sub>(n)</sub>位数</th>
<th>可寻址数</th>
<th>一条I2C总线最多<br>挂载同型号数量</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/doc0180.pdf" target="_blank" rel="noopener">AT24C16</a></td>
<td>2,048 x 8 (16K)</td>
<td>16-byte page</td>
<td>128</td>
<td>8bit</td>
<td><img src="/74fbdec2/AT24C16_Dev_Addr.png" alt="AT24C16_Dev_Addr"></td>
<td>0</td>
<td>3</td>
<td>256 x 2<sup>3</sup></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>根据<a href="#AT24Cxx%E7%B3%BB%E5%88%97%E5%8F%82%E6%95%B0%E8%A1%A8%E6%A0%BC">AT24Cxx系列参数表格</a>，AT24C16为 16-byte-page，发送地址为8bit，那么HAL_I2C_Mem_Read的MemAddSize参数传入I2C_MEMADD_SIZE_8BIT没有问题，那么参数<code>_EEPROM_SIZE_KBIT = 2</code>、<code>_EEPROM_PSIZE = 16</code> （16-byte-page）</p>
<p>注意24C16的I2C地址bit[1:3]用作P位，也就是一片24C16占用 8个7bit地址： <code>1010,000 - 1010,111</code>，即<code>0x50 - 0x57</code>，bit[0]用作读写(R/W)标识</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ee24_write</span><span class="params">(<span class="keyword">uint16_t</span> address, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> timeout)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        w = _EEPROM_PSIZE - (address  % _EEPROM_PSIZE);</span><br><span class="line">        <span class="keyword">if</span> (w &gt; len)</span><br><span class="line">            w = len;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">elif</span> (_EEPROM_SIZE_KBIT==16)</span></span><br><span class="line">            <span class="keyword">if</span> (HAL_I2C_Mem_Write(&amp;_EEPROM_I2C, _EEPROM_ADDRESS | ((address &amp; <span class="number">0x0700</span>) &gt;&gt; <span class="number">7</span>), (address &amp; <span class="number">0xff</span>), I2C_MEMADD_SIZE_8BIT, data, w, <span class="number">100</span>) == HAL_OK)</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ......</span><br><span class="line">        &#123;</span><br><span class="line">            ee24_delay(<span class="number">10</span>);</span><br><span class="line">            len -= w;</span><br><span class="line">            data += w;</span><br><span class="line">            address += w;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">                ee24_lock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">    ......</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相关宏和函数位置：</span></span><br><span class="line"><span class="comment">//stm32xxxx_hal_i2c.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_MEMADD_SIZE_8BIT            (0x00000001U)</span></span><br><span class="line"><span class="comment">//stm32xxxx_hal_i2c.c</span></span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_I2C_Mem_Write</span><span class="params">(I2C_HandleTypeDef *hi2c, <span class="keyword">uint16_t</span> DevAddress, <span class="keyword">uint16_t</span> MemAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">uint16_t</span> MemAddSize, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size, <span class="keyword">uint32_t</span> Timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>模拟一下写入过程：</p>
<ul>
<li>
<p>24C16 i2C 7bit地址有8个，但当所有P<sub>(n)</sub>位都为0时，8bit地址就是 <code>_EEPROM_ADDRESS = 1010,0000</code></p>
</li>
<li>
<p>假设：地址指针从EEPROM内部的<code>0x17</code>开始写，即二级制<code>address  = 0001,0111</code>，</p>
</li>
<li>
<p>假设：需要写入1byte的数据长度 <code>len = 43</code></p>
</li>
<li>
<p>代码段中的常量：</p>
<blockquote>
<p>_EEPROM_PSIZE = 16</p>
<p><code>0x0700</code>二进制为<code>0000,0111,0000,0000</code></p>
</blockquote>
</li>
</ul>
<p>手算太麻烦了，使用等效的测试代码打断点记录数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ee24_write_test_A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> address = <span class="number">0x17</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">43</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> <span class="built_in">array</span>[<span class="number">43</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">uint8_t</span> data = <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> w;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i;</span><br><span class="line">        w = <span class="number">16</span> - (address  % <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (w &gt; len)</span><br><span class="line">            w = len;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等效HAL_I2C_Mem_Write()的传入参数</span></span><br><span class="line">            <span class="keyword">uint8_t</span> DevAddress = _EEPROM_ADDRESS | ((address &amp; <span class="number">0x0700</span>) &gt;&gt; <span class="number">7</span>);</span><br><span class="line">            <span class="keyword">uint16_t</span> MemAddress = (address &amp; <span class="number">0xff</span>);</span><br><span class="line">            data;</span><br><span class="line">            w;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">/*断点位置*/</span> ee24_delay(<span class="number">10</span>);</span><br><span class="line">            len -= w;</span><br><span class="line">            data += w;</span><br><span class="line">            address += w;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次循环的记录当运行传到“断点&quot; “ HAL_I2C_Mem_Write() ”时，各个相关值：</p>
<table>
<thead>
<tr>
<th></th>
<th>第 1 次</th>
<th>第 2 次</th>
<th>第 3 次</th>
<th>第 4 次</th>
</tr>
</thead>
<tbody>
<tr>
<td>address (BIN) (DEC)</td>
<td>0000,0000,0001,0111 (23)</td>
<td>0000,0000,0010,0000 (32)</td>
<td>0000,0000,0011,0000 (48)</td>
<td>0000,0000,0100,0000 (64)</td>
</tr>
<tr>
<td>w 或 size (BIN) (DEC)</td>
<td>0000,1001 (9)</td>
<td>0001,0000 (16)</td>
<td>0001,0000 (16)</td>
<td>0000,0010 (2)</td>
</tr>
<tr>
<td>DevAddress (BIN)</td>
<td>1010,0000</td>
<td>1010,0000</td>
<td>1010,0000</td>
<td>1010,0000</td>
</tr>
<tr>
<td>MemAddress (BIN)</td>
<td>0000,0000,0001,0111</td>
<td>0000,0000,0010,0000</td>
<td>0000,0000,0011,0000</td>
<td>0000,0000,0100,0000</td>
</tr>
<tr>
<td>data 或 pData</td>
<td>&amp;array[0]</td>
<td>&amp;array[9]</td>
<td>&amp;array[25]</td>
<td>&amp;array[41]</td>
</tr>
<tr>
<td>len</td>
<td>43</td>
<td>34</td>
<td>18</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>24C16每页16yte，直觉感觉写入1byte的数据长度 <code>len = 43</code>只需要3次循环（16x3 = 48）就好了，但实际循环了4次！这与假设的address初始值为0x17有关！</p>
<p>该段数据在EEPROM的分布：EEPROM的字节寻址特性，不必像Flash一样地址对齐就能读写1byte或连续读写</p>
<p><img src="/74fbdec2/AT24C16_%E5%86%99%E5%88%86%E6%9E%901_%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.JPG" alt="IMG_0895"></p>
<p>以上情况24C16的<code> DevAddress</code>和<code>address</code>的高位没有发生变化，如果<code>address</code>变为<code>0x1fa</code>，I2C地址的P<sub>0</sub>和P<sub>1</sub>、address的高位发生变化：</p>
<table>
<thead>
<tr>
<th></th>
<th>第 1 次</th>
<th>第 2 次</th>
<th>第 3 次</th>
<th>第 4 次</th>
</tr>
</thead>
<tbody>
<tr>
<td>address(BIN) (DEC)</td>
<td>0000,0000,1111,1010 (506)</td>
<td>0000,00<span style="color:rgb(255, 175, 200);">1</span>0,0000,0000 (512)</td>
<td>0000,0010,0001,0000 (528)</td>
<td>0000,0010,0010,0000 (544)</td>
</tr>
<tr>
<td>w 或 size (BIN) (DEC)</td>
<td>0000,0110 (6)</td>
<td>0001,0000 (16)</td>
<td>0001,0000 (16)</td>
<td>0000,0101 (5)</td>
</tr>
<tr>
<td>DevAddress (BIN)</td>
<td>1010,0010</td>
<td>1010,0<span style="color:rgb(255, 175, 200);">10</span>0</td>
<td>1010,0100</td>
<td>1010,0100</td>
</tr>
<tr>
<td>MemAddress (BIN)</td>
<td>0000,0000,1111,1010</td>
<td>0000,00<span style="color:rgb(255, 175, 200);">0</span>0,0000,0000</td>
<td>0000,0000,0001,0000</td>
<td>0000,0000,0010,0000</td>
</tr>
<tr>
<td>data 或 pData</td>
<td>&amp;array[0]</td>
<td>&amp;array[6]</td>
<td>&amp;array[22]</td>
<td>&amp;array[38]</td>
</tr>
<tr>
<td>len</td>
<td>43</td>
<td>37</td>
<td>21</td>
<td>5</td>
</tr>
</tbody>
</table>
<h4 id="修改ee24库以支持24c1024"><a class="markdownIt-Anchor" href="#修改ee24库以支持24c1024"></a> 修改ee24库以支持24C1024</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//address升级为uint16_t, 添加#elif (_EEPROM_SIZE_KBIT == 1024)部分，函数其余部分不变</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ee24_write</span><span class="params">(<span class="keyword">uint32_t</span> address, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> timeout)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (_EEPROM_SIZE_KBIT == 1024)</span></span><br><span class="line">        <span class="keyword">if</span> (HAL_I2C_Mem_Write(&amp;_EEPROM_I2C, _EEPROM_ADDRESS | ((address &amp; <span class="number">0x10000</span>) &gt;&gt; <span class="number">15</span>), address, I2C_MEMADD_SIZE_16BIT, data, w, <span class="number">100</span>) == HAL_OK)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//address升级为uint16_t, 添加#elif (_EEPROM_SIZE_KBIT == 1024)部分，函数其余部分不变</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ee24_read</span><span class="params">(<span class="keyword">uint32_t</span> address, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> timeout)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (_EEPROM_SIZE_KBIT==1024)<span class="comment">// AT24C1024又有P位了</span></span></span><br><span class="line">    <span class="keyword">if</span> (HAL_I2C_Mem_Read(&amp;_EEPROM_I2C, _EEPROM_ADDRESS | ((address &amp; <span class="number">0x10000</span>) &gt;&gt; <span class="number">15</span>), address, I2C_MEMADD_SIZE_16BIT, data, len, <span class="number">100</span>) == HAL_OK)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟一下写入43个1byte数据到AT24C1024，<code>address</code>为<code>0xfff0</code></p>
<table>
<thead>
<tr>
<th></th>
<th>第 1 次</th>
<th>第 2 次</th>
<th>第 3 次</th>
</tr>
</thead>
<tbody>
<tr>
<td>address(BIN) (DEC)</td>
<td>0,1111,1111,1111,0000 (65520)</td>
<td><span style="color:rgb(255, 175, 200);">1</span>,0000,0000,0000,0000 (65536)</td>
<td>1,0000,0000,0001,0000 (65552)</td>
</tr>
<tr>
<td>w 或 size (BIN) (DEC)</td>
<td>0001,0000 (16)</td>
<td>0001,0000 (16)</td>
<td>0000,1011 (11)</td>
</tr>
<tr>
<td>DevAddress (BIN)</td>
<td>1010,0000</td>
<td>1010,00<span style="color:rgb(255, 175, 200);">1</span>0</td>
<td>1010,0010</td>
</tr>
<tr>
<td>MemAddress (BIN)</td>
<td>0000,0000,1111,0000</td>
<td>0000,0000,0000,0000</td>
<td>0000,0000,0001,0000</td>
</tr>
<tr>
<td>data 或 pData</td>
<td>&amp;array[0]</td>
<td>&amp;array[16]</td>
<td>&amp;array[32]</td>
</tr>
<tr>
<td>len</td>
<td>43</td>
<td>27</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>OK大功告成！</p>
<h2 id="eeprom检测大小"><a class="markdownIt-Anchor" href="#eeprom检测大小"></a> EEPROM检测大小</h2>
<h3 id="检测总大小"><a class="markdownIt-Anchor" href="#检测总大小"></a> 检测总大小</h3>
<p>利用地址指针溢出后回到第一页的特性</p>
<blockquote>
<p>给你一片不知道多大的EEPROM（比如丝印没了），如何快速得知它的容量？</p>
</blockquote>
<p>对<a href="https://github.com/RobTillaart/I2C_EEPROM/blob/1a6461a7dd5645ab3dcd148fbdc6dfc5ce6f9971/I2C_eeprom.cpp" target="_blank" rel="noopener">I2C_EEPROM/I2C_eeprom.cpp</a>的<code>I2C_eeprom::determineSize()</code>分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns size in bytes</span></span><br><span class="line"><span class="comment">// returns 0 if not connected</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   tested for</span></span><br><span class="line"><span class="comment">//   2 byte address</span></span><br><span class="line"><span class="comment">//   24LC512     64 KB    YES</span></span><br><span class="line"><span class="comment">//   24LC256     32 KB    YES</span></span><br><span class="line"><span class="comment">//   24LC128     16 KB    YES</span></span><br><span class="line"><span class="comment">//   24LC64       8 KB    YES</span></span><br><span class="line"><span class="comment">//   24LC32       4 KB    YES* - no hardware test, address scheme identical to 24LC64.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   1 byte address (uses part of deviceAddress byte)</span></span><br><span class="line"><span class="comment">//   24LC16       2 KB    YES</span></span><br><span class="line"><span class="comment">//   24LC08       1 KB    YES</span></span><br><span class="line"><span class="comment">//   24LC04      512 B    YES</span></span><br><span class="line"><span class="comment">//   24LC02      256 B    YES</span></span><br><span class="line"><span class="comment">//   24LC01      128 B    YES</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">I2C_eeprom::determineSize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> debug)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// try to read a byte to see if connected</span></span><br><span class="line">  <span class="keyword">if</span> (! isConnected()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint8_t</span> patAA = <span class="number">0xAA</span>;    <span class="comment">//1010,1010</span></span><br><span class="line">  <span class="keyword">uint8_t</span> pat55 = <span class="number">0x55</span>; <span class="comment">//0101,0101</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 每次倍增size，注意size即作检测的EEPROM大小，也作为地址指针位置</span></span><br><span class="line"><span class="comment">   * 对于24C01，size = 127是最末尾的byte，size = 128 会循环覆盖到 0</span></span><br><span class="line"><span class="comment">   * 对于24C02，size = 255是最末尾的byte，size = 256 会循环覆盖到 0</span></span><br><span class="line"><span class="comment">   * ......</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> <span class="built_in">size</span> = <span class="number">128</span>; <span class="built_in">size</span> &lt;= <span class="number">65536</span>; <span class="built_in">size</span> *= <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">bool</span> folded = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store old values</span></span><br><span class="line">    <span class="comment">//bool addressSize = _isAddressSizeTwoWords;            //依赖构造函数传是否是2byte地址, 不依赖，可以不初始化该值</span></span><br><span class="line">    _isAddressSizeTwoWords = <span class="built_in">size</span> &gt; I2C_DEVICESIZE_24LC16;  <span class="comment">//如果size倍增迭代大于2048Kbit，那么_isAddressSizeTwoWords = true</span></span><br><span class="line">    <span class="keyword">uint8_t</span> buf = readByte(<span class="built_in">size</span>);        <span class="comment">//去读地址指针=size处地址的1byte值，临时存起来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// test folding 测试折叠</span></span><br><span class="line">    <span class="keyword">uint8_t</span> cnt = <span class="number">0</span>;                    <span class="comment">//统计页的大小，以byte为单位</span></span><br><span class="line">    writeByte(<span class="built_in">size</span>, pat55);                <span class="comment">//对size地址写入 0101,0101</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果首地址的值与写入的值相同，说明地址指针溢出后回到第一页地址，</span></span><br><span class="line"><span class="comment">     * 第一页之前的数据将被覆盖，不过没关系，我们事先存了副本到buf中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (readByte(<span class="number">0</span>) == pat55) cnt++;</span><br><span class="line"></span><br><span class="line">    writeByte(<span class="built_in">size</span>, patAA);                <span class="comment">//对size地址继续写入 1010,1010，地址指针会自增吗？</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果首地址的值与写入的值相同，说明页发生了折叠</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (readByte(<span class="number">0</span>) == patAA) cnt++;</span><br><span class="line">    folded = (cnt == <span class="number">2</span>);    <span class="comment">//如果cnt==2，那么发生了折叠</span></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">Serial</span>.<span class="built_in">print</span>(<span class="built_in">size</span>, HEX);</span><br><span class="line">      <span class="built_in">Serial</span>.<span class="built_in">print</span>(<span class="string">'\t'</span>);</span><br><span class="line">      <span class="built_in">Serial</span>.<span class="built_in">println</span>(readByte(<span class="built_in">size</span>), HEX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore old values    //恢复原有的数据，也就是说这个测试不会破坏原有的数据，考虑很周到</span></span><br><span class="line">    writeByte(<span class="built_in">size</span>, buf);</span><br><span class="line">    <span class="comment">//_isAddressSizeTwoWords = addressSize;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (folded) <span class="keyword">return</span> <span class="built_in">size</span>;    <span class="comment">//发生了折叠，返回size就是检测的EEPROM大小</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，抬头的注释：对于24C16及以下容量的型号，使用1byte address检测，24C32及以上容量的型号，使用
2byte address检测，地址长度的变化根据I2C_eeprom类的成员<code>_isAddressSizeTwoWords</code> 的值在<code>I2C_eeprom::_beginTransmission()</code>中更改，相关代码节选：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  supports one and two bytes addresses</span></span><br><span class="line"><span class="keyword">void</span> I2C_eeprom::_beginTransmission(<span class="keyword">const</span> <span class="keyword">uint16_t</span> memoryAddress)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_isAddressSizeTwoWords)</span><br><span class="line">  &#123;</span><br><span class="line">  _wire-&gt;<span class="built_in">beginTransmission</span>(_deviceAddress);</span><br><span class="line">    <span class="comment">// Address High Byte</span></span><br><span class="line">    _wire-&gt;<span class="built_in">write</span>((memoryAddress &gt;&gt; <span class="number">8</span>));            <span class="comment">//左移8bit，发送高位8bit</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> addr = _deviceAddress | ((memoryAddress &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x07</span>);</span><br><span class="line">    _wire-&gt;<span class="built_in">beginTransmission</span>(addr);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Address Low Byte (or single byte for chips 16K or smaller that have one-word addresses)</span></span><br><span class="line">  _wire-&gt;<span class="built_in">write</span>((memoryAddress &amp; <span class="number">0xFF</span>));            <span class="comment">//将bit[15:8]置0, 发送低位8bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_isAddressSizeTwoWords</code> 默认未初始化，必须在I2C_eeprom类其中一个构造函数中传入deviceSize，才会初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I2C_eeprom</span> &#123;</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//  24LC32..24LC512 use two bytes for memory address</span></span><br><span class="line">  <span class="comment">//  24LC01..24LC16  use one-byte addresses + part of device address</span></span><br><span class="line">  <span class="keyword">bool</span>     _isAddressSizeTwoWords;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">I2C_eeprom::I2C_eeprom(<span class="keyword">const</span> <span class="keyword">uint8_t</span> deviceAddress, TwoWire *wire)</span><br><span class="line">&#123;</span><br><span class="line">    I2C_eeprom(deviceAddress, I2C_PAGESIZE_24LC256, wire);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据传入的deviceSize初始化_isAddressSizeTwoWords</span></span><br><span class="line">I2C_eeprom::I2C_eeprom(<span class="keyword">const</span> <span class="keyword">uint8_t</span> deviceAddress, <span class="keyword">const</span> <span class="keyword">uint32_t</span> deviceSize, TwoWire *wire)</span><br><span class="line">&#123;</span><br><span class="line">    _deviceAddress = deviceAddress;</span><br><span class="line">    _deviceSize = deviceSize;</span><br><span class="line">    _pageSize = getPageSize(_deviceSize);</span><br><span class="line">    _wire = wire;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Chips 16Kbit (2048 Bytes) or smaller only have one-word addresses.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_isAddressSizeTwoWords = deviceSize &gt; I2C_DEVICESIZE_24LC16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个检测逻辑如果不给定<code>deviceSize</code>，就没法得知<code>_isAddressSizeTwoWords</code>，假真不给定<code>deviceSize</code>那如何检测容量？很简单，让<code>uint32_t I2C_eeprom::determineSize()</code>以1byte和2byte长度的地址各测试一遍，取计算结果偏大的，我分别进行了以下测试，可以看出该方法理论上可行：</p>
<table>
<thead>
<tr>
<th>被检测型号</th>
<th>address长度</th>
<th>检测的size</th>
<th>检测page</th>
</tr>
</thead>
<tbody>
<tr>
<td>24C02</td>
<td>1byte</td>
<td>256</td>
<td>8</td>
</tr>
<tr>
<td>24C02</td>
<td>2byte</td>
<td>128</td>
<td>8</td>
</tr>
<tr>
<td>24C128</td>
<td>1byte</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>24C128</td>
<td>2byte</td>
<td>16384</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>对于24C1024，地址指针有1位在I2C P0位，实际是17bit寻址，所有该库uint16 address无法检测，需要升级类型到32bit，或者在<code>I2C_eeprom::determineSize()</code>检测到为65536时，更改I2C地址bit[1]，再次检测，看还是不是65536</p>
<h3 id="检测页大小"><a class="markdownIt-Anchor" href="#检测页大小"></a> 检测页大小</h3>
<p>根据之前的总大小自动返回页大小就行，没有用到页覆盖特性（不搞这么麻烦，简单粗暴）</p>
<p>另外，24C1024的Page size是256byte，还可以加一行if</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">I2C_eeprom::getPageSize</span><span class="params">(<span class="keyword">uint32_t</span> deviceSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// determine page size from device size - based on Microchip 24LCXX data sheets.</span></span><br><span class="line">    <span class="keyword">if</span> (deviceSize &lt;= I2C_DEVICESIZE_24LC02) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (deviceSize &lt;= I2C_DEVICESIZE_24LC16) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (deviceSize &lt;= I2C_DEVICESIZE_24LC64) <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">if</span> (deviceSize &lt;= I2C_DEVICESIZE_24LC256) <span class="keyword">return</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// I2C_DEVICESIZE_24LC512</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">128</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改arduino库的实现到ee24库"><a class="markdownIt-Anchor" href="#修改arduino库的实现到ee24库"></a> 修改arduino库的实现到EE24库</h3>
<p>以下是检测页和Page大小的函数（我用 class 将 ee24 库套了一层）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">EE24::determine_memsize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// try to read a byte to see if connected</span></span><br><span class="line">    <span class="keyword">if</span> (! isConnected()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设为测试值</span></span><br><span class="line">    _sizePageByte = <span class="number">8</span>;</span><br><span class="line">    _addrBitAndDev = <span class="number">0xff</span>;</span><br><span class="line">    _addrBitRightOffSet = <span class="number">0</span>;</span><br><span class="line">    _addrBitAndMem =  <span class="number">0x1ffff</span>;</span><br><span class="line">    _memAddSize = I2C_MEMADD_SIZE_8BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> patAA = <span class="number">0xAA</span>;    <span class="comment">//1010,1010</span></span><br><span class="line">    <span class="keyword">uint8_t</span> pat55 = <span class="number">0x55</span>; <span class="comment">//0101,0101</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 每次倍增size，注意size即作检测的EEPROM大小，也作为地址指针位置</span></span><br><span class="line"><span class="comment">     * 对于24C01，size = 127是最末尾的byte，size = 128 会循环覆盖到 0</span></span><br><span class="line"><span class="comment">     * 对于24C02，size = 255是最末尾的byte，size = 256 会循环覆盖到 0</span></span><br><span class="line"><span class="comment">     * ......</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> sizePrev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> sizeLater = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> folded;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">1</span>)</span><br><span class="line">            _memAddSize = I2C_MEMADD_SIZE_16BIT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">size</span> = <span class="number">128</span>; <span class="built_in">size</span> &lt;= <span class="number">65536</span>; <span class="built_in">size</span> *= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            folded = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//            uint8_t buf;</span></span><br><span class="line"><span class="comment">//            readByte(size,&amp;buf);        //去读地址指针=size处地址的1byte值，临时存起来</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// test folding 测试折叠</span></span><br><span class="line">            <span class="keyword">uint8_t</span> cnt = <span class="number">0</span>;            <span class="comment">//统计页的大小，以byte为单位</span></span><br><span class="line">            writeByte(<span class="built_in">size</span>,  &amp;pat55);     <span class="comment">//对size地址写入 0101,0101</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint8_t</span> readBuffer;</span><br><span class="line">            readByte( <span class="number">0</span>, &amp;readBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (readBuffer == pat55) cnt++;    <span class="comment">//如果首地址的值与写入的值相同，说明地址指针溢出后回到第一页地址， 第一页之前的数据将被覆盖，不过没关系，我们事先存了副本到buf中</span></span><br><span class="line">            writeByte(<span class="built_in">size</span>, &amp;patAA);         <span class="comment">//对size地址继续写入 1010,1010，地址指针会自增吗？</span></span><br><span class="line"></span><br><span class="line">            readByte( <span class="number">0</span>,  &amp;readBuffer);</span><br><span class="line">            <span class="keyword">if</span> (readBuffer == patAA) cnt++;    <span class="comment">//如果首地址的值与写入的值相同，说明页发生了折叠</span></span><br><span class="line"></span><br><span class="line">            folded = (cnt == <span class="number">2</span>);            <span class="comment">//如果cnt==2，那么发生了折叠</span></span><br><span class="line"></span><br><span class="line">            readByte(<span class="built_in">size</span>, &amp;readBuffer);</span><br><span class="line">            DBG_EE24(<span class="string">"size = %d,read address size: %d  "</span>, <span class="built_in">size</span>, readBuffer);</span><br><span class="line"><span class="comment">//            writeByte(size, &amp;buf); // restore old values    //恢复原有的数据，也就是说这个测试不会破坏原有的数据，但对8bit地址指针使用16bit搞不一定</span></span><br><span class="line">            <span class="keyword">if</span> (folded) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">size</span> &gt; <span class="number">65535</span>) <span class="built_in">size</span> = <span class="number">0</span>;    <span class="comment">//说明16bit地址指针溢出</span></span><br><span class="line">                    sizePrev = <span class="built_in">size</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//j == 1</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">size</span> &gt; <span class="number">65535</span>) <span class="built_in">size</span> = <span class="number">0</span>;    <span class="comment">//说明16bit地址指针溢出</span></span><br><span class="line">                    sizeLater = <span class="built_in">size</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果至少一个size非零, 那肯定发生了折叠，可以确定地址值位数</span></span><br><span class="line">    <span class="keyword">if</span>(sizePrev | sizeLater)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sizePrev &lt; sizeLater) &#123;</span><br><span class="line">            _memAddSize = I2C_MEMADD_SIZE_16BIT;</span><br><span class="line">            <span class="built_in">size</span> = sizeLater;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _memAddSize = I2C_MEMADD_SIZE_8BIT;</span><br><span class="line">            <span class="built_in">size</span> = sizePrev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span> / <span class="number">128</span>;    <span class="comment">//以Kbit单位返回，例如24C128返回128</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   tested for 2 byte address</span></span><br><span class="line"><span class="comment">//   24LC1024     128 KB    待测试</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">EE24::determineMemSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">size</span> = determine_memsize();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == I2C_DEVICESIZE_24LC512)&#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> devAddrOld = _devAddress;</span><br><span class="line">        _devAddress = _devAddress | <span class="number">0x2</span>; <span class="comment">//更改P0位以检测24C1024</span></span><br><span class="line">        <span class="keyword">if</span>(determine_memsize() == I2C_DEVICESIZE_24LC512)</span><br><span class="line">            <span class="built_in">size</span> = I2C_DEVICESIZE_24LC1024;</span><br><span class="line">        _devAddress = devAddrOld;    <span class="comment">//还原地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    _sizeMemKbit = <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">EE24::determinePageSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">// determine page size from device size - based on Microchip 24LCXX data sheets.</span></span><br><span class="line">    <span class="keyword">if</span> (_sizeMemKbit &lt;= I2C_DEVICESIZE_24LC02) <span class="built_in">size</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_sizeMemKbit &lt;= I2C_DEVICESIZE_24LC16) <span class="built_in">size</span> = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_sizeMemKbit &lt;= I2C_DEVICESIZE_24LC64) <span class="built_in">size</span> = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_sizeMemKbit &lt;= I2C_DEVICESIZE_24LC256) <span class="built_in">size</span> = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_sizeMemKbit &lt;= I2C_DEVICESIZE_24LC512) <span class="built_in">size</span> = <span class="number">128</span>;</span><br><span class="line">    <span class="comment">// I2C_DEVICESIZE_24LC1024</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">size</span> = <span class="number">256</span>;</span><br><span class="line">    _sizePageByte = <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="eepprom存储数据"><a class="markdownIt-Anchor" href="#eepprom存储数据"></a> EEPPROM存储数据</h2>
<h3 id="将结构体存到eeprom"><a class="markdownIt-Anchor" href="#将结构体存到eeprom"></a> 将结构体存到EEPROM</h3>
<h4 id="union结合struct的技巧"><a class="markdownIt-Anchor" href="#union结合struct的技巧"></a> union结合struct的技巧</h4>
<p>EEPROM不论是1byte、多个byte、页的读写，每一次目标地址的迭代单位都是1byte，也就是说对于2byte及以上的单个类型（例如 uint16_t、int16_t、float、long、double等）不能直接用1byte迭代的读写函数，需要将这种类型拆分成多个1byte，存进去。取出来，也要再经历组合操作，转换成原来的类型，标准方法是使用 union：</p>
<p>联合体保存float到eeprom的方法</p>
<blockquote>
<p>联合体看似与结构体相似，但有不同之处，结构体中每个变量占用不同的内存，而联合体共用一段内存</p>
<p>联合体同一时间只用到一个成员</p>
<p>结构体变量所占内存长度是其中最大字段大小的整数倍</p>
<p>共用体变量所占的内存长度等于最长的成员变量的长度</p>
</blockquote>
<p><a href="https://blog.csdn.net/mrwangwang/article/details/49706005" target="_blank" rel="noopener">在EEPROM中保存浮点数的方法_mrwangwang的博客</a></p>
<p><a href="https://www.geek-workshop.com/thread-2323-1-1.html" target="_blank" rel="noopener">Arduino中利用EEPROM存储double和float类型的数据（使用共用体）</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/unions?view=msvc-170" target="_blank" rel="noopener">union_Microsoft_Docs</a></p>
<p>🐂🍺<a href="https://www.eet-china.com/mp/a34530.html" target="_blank" rel="noopener">结构体内嵌联合体 在数据组包和解包的应用、Ti单片寄存器封装：union内嵌位域结构体、管理状态变量</a></p>
<p><a href="https://www.amobbs.com/thread-5636688-1-1.html" target="_blank" rel="noopener">amobbs：如何方便的读写结构体到EEPROM中？</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sensor_rom_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> addr;   </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> altimes;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> exist;<span class="comment">//设置的状态</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ctr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> relay;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> cf_page</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sensor_rom_t</span> <span class="title">s</span>[<span class="title">ALMMAX</span>];</span><span class="comment">//ALMMAX是存成结构体数组        //获取结构体值时，使用s</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> str[<span class="keyword">sizeof</span>(struct <span class="keyword">sensor_rom_t</span>) * ALMMAX];   <span class="comment">//读写EEPROM时，使用str </span></span><br><span class="line">&#125; cf;</span><br></pre></td></tr></table></figure>
<p>把 union 的 str 成员用 eeprom_write 写到eeprom里就可以了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eeprom_write((<span class="keyword">uint8_t</span> *)&amp;structx, <span class="keyword">sizeof</span>(structx));</span><br></pre></td></tr></table></figure>
<p>不过有个问题,，结构体有不同类型的成员，编译器可能插入填充字节进行<strong>字节对齐</strong>，结构体实际大小可能大于其成员大小的总和，这种情况的结构体如果是union 的成员，那么用union的另一个成员保存到EEPROM，会造成EEPROM空间浪费？先Mark一下，以后再想想</p>
<h4 id="sau-g0的系统设置的存储结构"><a class="markdownIt-Anchor" href="#sau-g0的系统设置的存储结构"></a> SAU-G0的系统设置的存储结构</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径 Settings.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">orgData</span>&#123;</span></span><br><span class="line">    <span class="comment">//版本信息</span></span><br><span class="line">    <span class="keyword">uint16_t</span> FWversion;</span><br><span class="line">    <span class="comment">//数据采集</span></span><br><span class="line">    <span class="keyword">uint32_t</span> TimeRUN;                <span class="comment">// 累计运行时间--RUN</span></span><br><span class="line">    <span class="keyword">uint32_t</span> TimeLPW_RUN;            <span class="comment">// 累计运行时间--LPW_RUN</span></span><br><span class="line">    <span class="keyword">uint32_t</span> TImeSTOP1;                <span class="comment">// 累计运行时间--STOP1</span></span><br><span class="line">    <span class="keyword">uint16_t</span> NumOfDataCollected;    <span class="comment">// 已采集的数据组个数(也用于下次写EEPROM地址的指针偏移)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> NumOfDataWillCollect;    <span class="comment">// 将采集的数据组个数</span></span><br><span class="line">    <span class="comment">//任务开始日期</span></span><br><span class="line">    <span class="keyword">uint16_t</span> STyy;</span><br><span class="line">    <span class="keyword">uint16_t</span> STMM;</span><br><span class="line">    <span class="keyword">uint16_t</span> STdd;</span><br><span class="line">    <span class="keyword">uint16_t</span> SThh;</span><br><span class="line">    <span class="keyword">uint16_t</span> STmm;</span><br><span class="line">    <span class="keyword">uint16_t</span> STss;</span><br><span class="line">    <span class="comment">//任务采集周期（+ 任务开始日期，可以配合RTClib的opertor算出结束日期）</span></span><br><span class="line">    <span class="keyword">uint16_t</span> Thh;    <span class="comment">//&gt;24小时后, 换算为天</span></span><br><span class="line">    <span class="keyword">uint16_t</span> Tmm;</span><br><span class="line">    <span class="keyword">uint16_t</span> Tss;</span><br><span class="line">    <span class="comment">//每个周期采集样本数（给滤波器的处理为一组数据，不会存未经滤波的多个数据组）</span></span><br><span class="line">    <span class="keyword">uint16_t</span> TSamples;                        <span class="comment">//暂时不支持单独设置某一对象的样本数</span></span><br><span class="line">    <span class="comment">//这个其实当全局变量好了，不需要存在eeprom</span></span><br><span class="line">    <span class="comment">//日期时间</span></span><br><span class="line">    <span class="keyword">uint16_t</span> yy;    <span class="comment">//0~99</span></span><br><span class="line">    <span class="keyword">uint16_t</span> MM;</span><br><span class="line">    <span class="keyword">uint16_t</span> dd;</span><br><span class="line">    <span class="keyword">uint16_t</span> hh;</span><br><span class="line">    <span class="keyword">uint16_t</span> mm;</span><br><span class="line">    <span class="keyword">uint16_t</span> ss;</span><br><span class="line">    <span class="comment">//显示设置</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ScreenBrightness;    <span class="comment">// 0~100% 屏幕亮度</span></span><br><span class="line">    <span class="comment">//熄屏唤醒</span></span><br><span class="line">    <span class="keyword">uint16_t</span> Sensitivity;         <span class="comment">// 0~100% 动作阈值</span></span><br><span class="line">    <span class="keyword">uint16_t</span> SleepTime;         <span class="comment">// 0~999S 亮屏时间</span></span><br><span class="line">    <span class="comment">//开关标志</span></span><br><span class="line">    settingsBitsType settingsBits[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * systemStorageType</span></span><br><span class="line"><span class="comment"> * 用于片外 EEPROM 储存设置信息和数据采集信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">orgData</span> <span class="title">data</span>;</span>            <span class="comment">//运行时使用</span></span><br><span class="line">    <span class="keyword">uint8_t</span> ctrl[<span class="keyword">sizeof</span>(orgData)];    <span class="comment">//向eeprom读写时使用</span></span><br><span class="line">&#125; systemStorageType;</span><br></pre></td></tr></table></figure>
<h4 id="如何节约标志位的空间"><a class="markdownIt-Anchor" href="#如何节约标志位的空间"></a> 如何节约标志位的空间？</h4>
<blockquote>
<p>注：”Colum“ 的正确拼写是 &quot;Column&quot;，后文都是用 ”Colum“ 是我的历史遗留问题，见笑了</p>
</blockquote>
<p>SAU-G0的系统设置里有很多“开启”或”关闭“的设置，如果用uint8_t，或uint16_t存放，非常耗费EEPROM容量，使用前面提到的技巧</p>
<p>系统设置是systemStorageType类型，它的data成员的settingsBits[2]数组，是settingsBitsType类型，其使用union内嵌位域结构体，每个settings_Bits结构可存8个标志位（0或1）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径 Settings.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sysBits 0    <span class="comment">//表示系统设置</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> colBits 1    <span class="comment">//表示采样设置</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">settings_Bits</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> bit0     :<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> bit1     :<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> bit2     :<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> bit3     :<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> bit4     :<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> bit5     :<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> bit6     :<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> bit7     :<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span>&#123;</span><br><span class="line">    settings_Bits bits;</span><br><span class="line">    <span class="keyword">uint8_t</span> ctrl;        <span class="comment">//    colum对象成员prBits和mask修改bits时使用</span></span><br><span class="line">&#125;settingsBitsType;</span><br></pre></td></tr></table></figure>
<p>在实现多级菜单的Page类中也实现了对位域的修改，例如构造colum时可传入 <code>指向settingsBitsType的指针</code> + <code>对应bit的掩码</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径 colum.hpp</span></span><br><span class="line">Class colum &#123; </span><br><span class="line">......</span><br><span class="line">        colum(<span class="keyword">const</span> <span class="keyword">char</span> *Str, settingsBitsType* Bits, <span class="keyword">uint8_t</span> Mask)  :</span><br><span class="line">        str(Str), ptrBits(Bits), mask(Mask)&#123;&#125;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//路径 CutomPageObjects.cpp，实例化colum对象</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;colum&gt; columsScreenOffAndWKUP = &#123;</span><br><span class="line">......</span><br><span class="line">        colum(<span class="string">"自动休眠"</span>, &amp;systemSto.data.settingsBits[sysBits], B00000001),</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>changeSettingsBitByMask()实现修改位，类似于I2C读写寄存器指定位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径 Page.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeSettingsBitByMask</span><span class="params">(settingsBitsType * ptrBits, <span class="keyword">uint8_t</span> mask)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> b = ptrBits-&gt;ctrl;    <span class="comment">//先备份一个</span></span><br><span class="line">    (b &amp; mask)?            <span class="comment">//若b对应mask为1的位为1</span></span><br><span class="line">        (b = b &amp; ~mask)        <span class="comment">//不改变b对应mask为0位的值，将mask为1的值改为0</span></span><br><span class="line">    :                    <span class="comment">//b对应mask为1的位为0</span></span><br><span class="line">        (b = b | mask);        <span class="comment">//不改变b对应mask为0位的值，将mask为0的值改为1</span></span><br><span class="line"><span class="comment">//参考                b = (data != 0) ? (b | mask) : (b &amp; ~mask);</span></span><br><span class="line">    ptrBits-&gt;ctrl = b;    <span class="comment">//保存b到结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试union内嵌位域结构体作为colum构造函数参数，在Debug下查看位域修改情况：</p>
<p><img src="/74fbdec2/union%E5%86%85%E5%B5%8C%E4%BD%8D%E5%9F%9F%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BAColum%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%9C%A8Debug%E4%B8%8B%E6%9F%A5%E7%9C%8B%E4%BD%8D%E5%9F%9F%E4%BF%AE%E6%94%B9%E6%83%85%E5%86%B5.png" alt="union内嵌位域结构体作为Colum构造函数参数在Debug下查看位域修改情况"></p>
<h3 id="sau-g0采集数据的格式"><a class="markdownIt-Anchor" href="#sau-g0采集数据的格式"></a> SAU-G0采集数据的格式</h3>
<p>存SAU-G0采集数据的EEPROM建议24C16（16Kbit容量）以上，因为 24C16刚好是2KB，与G031 Flash的页大小一样，存满了可以拷贝到G031的Flash的一个页里</p>
<p>对于24C16，每小时存一组（温度16bit+湿度16bit）的采集数据，可以存20天，消耗1920byte，余下的128byte，支持每天用6byte存一次日期，还余下8byte，6byte日期数据如下：</p>
<table>
<thead>
<tr>
<th>大小</th>
<th>1byte</th>
<th>1byte</th>
<th>1byte</th>
<th>1byte</th>
<th>1byte</th>
<th>1byte</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>uint8_t</td>
<td>uint8_t</td>
<td>uint8_t</td>
<td>uint8_t</td>
<td>uint8_t</td>
<td>uint8_t</td>
</tr>
<tr>
<td>举个栗子</td>
<td>22</td>
<td>5</td>
<td>23</td>
<td>16</td>
<td>04</td>
<td>23</td>
</tr>
<tr>
<td>单位</td>
<td>年</td>
<td>月</td>
<td>日</td>
<td>时</td>
<td>分</td>
<td>秒</td>
</tr>
</tbody>
</table>
<p>4byte温湿度采集数据如下：</p>
<table>
<thead>
<tr>
<th>大小</th>
<th>2byte</th>
<th>2byte</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>uint16_t</td>
<td>uint16_t</td>
</tr>
<tr>
<td>举个栗子</td>
<td>25.7</td>
<td>63.2</td>
</tr>
<tr>
<td>单位</td>
<td>℃或℉</td>
<td>%</td>
</tr>
</tbody>
</table>
<p>即使24C16只有2KB最多存20天，但拷贝到flash后，只要G031 的 Flash空间还有，每页就能多存20天</p>
<h3 id="串口输出eeprom存储的采集数据"><a class="markdownIt-Anchor" href="#串口输出eeprom存储的采集数据"></a> 串口输出EEPROM存储的采集数据</h3>
<p>流程：每24次里 从EEPEOM读1次日期，读24次温湿度数据，转成字符串，分配一个缓冲区，将热乎的字符串数据格式化成MarkDown表格的编码结构</p>
<p>举个例子，想要串口输出成这样子的：（注意时间和日期没有前导0）</p>
<table>
<thead>
<tr>
<th>Date &amp; Time</th>
<th>T(℃)</th>
<th>H(%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2022/5/10 8:00</td>
<td>8.72</td>
<td>5.83</td>
</tr>
<tr>
<td>2022/5/10 10:00</td>
<td>22.54</td>
<td>58.44</td>
</tr>
<tr>
<td>2022/5/10 12:00</td>
<td>25.67</td>
<td>53.12</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> 时间            </span>|<span class="string"> 温度(℃) </span>|<span class="string"> 湿度(%) </span>|</span><br><span class="line">|<span class="string"> --------------- </span>|<span class="string"> ------- </span>|<span class="string"> ------- </span>|</span><br><span class="line">|<span class="string"> 2022/5/10 08:00 </span>|<span class="string"> 18.7    </span>|<span class="string"> 65.8    </span>|</span><br><span class="line">|<span class="string"> 2022/5/10 10:00 </span>|<span class="string"> 22.5    </span>|<span class="string"> 58.4    </span>|</span><br><span class="line">|<span class="string"> 2022/5/10 12:00 </span>|<span class="string"> 25.6    </span>|<span class="string"> 53.1    </span>|</span><br><span class="line">|<span class="string"> ...             </span>|<span class="string"> ...     </span>|<span class="string"> ...     </span>|</span><br></pre></td></tr></table></figure>
<p>不算表格抬头，一次输出一行，至少得分配42byte作为TxBuffer</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| <span class="number">2022</span>/<span class="number">5</span>/<span class="number">10</span> <span class="number">08</span>:<span class="number">00</span> | <span class="number">18.7</span>    | <span class="number">65.8</span>    |  \r \n \<span class="number">0</span></span><br><span class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line"><span class="number">012345678901234567890123456789012345678</span>  <span class="number">9</span>  <span class="number">0</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>相关实现在 <a href="https://github.com/oldgerman/SAU-G0/blob/master/SoftWare/SAU-G031G8U6/USER/GUI/Menu/CustomPageFuc.cpp#L210" target="_blank" rel="noopener">columsDataCollect_Export</a></p>
<h2 id="附"><a class="markdownIt-Anchor" href="#附"></a> 附</h2>
<h3 id="eeprom-字节对齐"><a class="markdownIt-Anchor" href="#eeprom-字节对齐"></a> EEPROM 字节对齐？</h3>
<p><a href="https://github.com/RobTillaart/I2C_EEPROM/blob/1a6461a7dd5645ab3dcd148fbdc6dfc5ce6f9971/I2C_eeprom.cpp" target="_blank" rel="noopener">I2C_EEPROM/I2C_eeprom.cpp</a>，这个库实现了EEPROM字节对齐</p>
<p><a href="https://www.cnblogs.com/King-Gentleman/p/5297355.html" target="_blank" rel="noopener">stm32使用#pragma pack（非常详细的字节对齐用法说明）</a></p>
<p><a href="http://www.openedv.com/thread-7415-1-1.html" target="_blank" rel="noopener">STM32 FATFS结构体的字节对齐问题.所以建议大家在自己建立结构体的时候,最好加上__packed关键字</a></p>
<h3 id="excel-技巧"><a class="markdownIt-Anchor" href="#excel-技巧"></a> Excel 技巧</h3>
<p><a href="https://zhuanlan.zhihu.com/p/85613944" target="_blank" rel="noopener">excel录入技巧：如何进行日期格式的转换，真日期vs假日期</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/149604904" target="_blank" rel="noopener">Excel时间计算公式大全</a></p>
<p><a href="https://support.microsoft.com/zh-cn/office/%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%97%B6%E9%97%B4%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%80%BC-e1c78778-749b-49a3-b13e-737715505ff6" target="_blank" rel="noopener">计算两个时间之间的差值 support.microsoft</a></p>
<p><a href="https://www.bilibili.com/s/video/BV1jh411y7bz" target="_blank" rel="noopener">如何在excel中求气温距平序列</a></p>

    </div>

    
    
    
        
      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>过气德国佬</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://oldgerman.github.io/74fbdec2/" title="SAU-G0 EEPROM笔记">http://oldgerman.github.io/74fbdec2/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/stm32/" rel="tag"># stm32</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/1eb159fd/" rel="next" title="nRLC音频头版组装指南">
                  <i class="fa fa-chevron-left"></i> nRLC音频头版组装指南
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/5cea6320/" rel="prev" title="OpenHeat-Split">
                  OpenHeat-Split <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/OldGerman.jpg"
      alt="过气德国佬">
  <p class="site-author-name" itemprop="name">过气德国佬</p>
  <div class="site-description motion-element" itemprop="description">潮起潮落，云卷云舒</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/oldgerman" title="GitHub &rarr; https://github.com/oldgerman" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:2920956602@qq.com" title="E-Mail &rarr; mailto:2920956602@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>




        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text"> 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eeprom参数表格at24cxx系列"><span class="nav-number">2.</span> <span class="nav-text"> EEPROM参数表格（AT24Cxx系列）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ee24"><span class="nav-number">3.</span> <span class="nav-text"> ee24（开源EEPROM驱动库 STM32 HAL）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eeprom擦除"><span class="nav-number">4.</span> <span class="nav-text"> EEPROM擦除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一般擦除法"><span class="nav-number">4.1.</span> <span class="nav-text"> 一般擦除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊擦除法"><span class="nav-number">4.2.</span> <span class="nav-text"> 特殊擦除法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eeprom页大小"><span class="nav-number">5.</span> <span class="nav-text"> EEPROM页大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eeprom寻址"><span class="nav-number">6.</span> <span class="nav-text"> EEPROM寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分析为at24c02的情况"><span class="nav-number">6.0.1.</span> <span class="nav-text"> 分析为AT24C02的情况：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析为at24c16的情况"><span class="nav-number">6.0.2.</span> <span class="nav-text"> 分析为AT24C16的情况：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改ee24库以支持24c1024"><span class="nav-number">6.0.3.</span> <span class="nav-text"> 修改ee24库以支持24C1024</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eeprom检测大小"><span class="nav-number">7.</span> <span class="nav-text"> EEPROM检测大小</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检测总大小"><span class="nav-number">7.1.</span> <span class="nav-text"> 检测总大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测页大小"><span class="nav-number">7.2.</span> <span class="nav-text"> 检测页大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改arduino库的实现到ee24库"><span class="nav-number">7.3.</span> <span class="nav-text"> 修改arduino库的实现到EE24库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eepprom存储数据"><span class="nav-number">8.</span> <span class="nav-text"> EEPPROM存储数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#将结构体存到eeprom"><span class="nav-number">8.1.</span> <span class="nav-text"> 将结构体存到EEPROM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#union结合struct的技巧"><span class="nav-number">8.1.1.</span> <span class="nav-text"> union结合struct的技巧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sau-g0的系统设置的存储结构"><span class="nav-number">8.1.2.</span> <span class="nav-text"> SAU-G0的系统设置的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何节约标志位的空间"><span class="nav-number">8.1.3.</span> <span class="nav-text"> 如何节约标志位的空间？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sau-g0采集数据的格式"><span class="nav-number">8.2.</span> <span class="nav-text"> SAU-G0采集数据的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串口输出eeprom存储的采集数据"><span class="nav-number">8.3.</span> <span class="nav-text"> 串口输出EEPROM存储的采集数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附"><span class="nav-number">9.</span> <span class="nav-text"> 附</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eeprom-字节对齐"><span class="nav-number">9.1.</span> <span class="nav-text"> EEPROM 字节对齐？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#excel-技巧"><span class="nav-number">9.2.</span> <span class="nav-text"> Excel 技巧</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>




        

<div id="days"></div>
<script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("07/19/2019 15:00:00");
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
    secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
    e_daysold=timeold/msPerDay
    daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="(∩•̀ω•́)⊃--*⋆本站由米板1代搭建，已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";
}
function setzero(i) {
    if (i<10) {
        i="0" + i
    };
    return i;
}
show_date_time();
</script>




      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">过气德国佬</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">160k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.3.0</div>

        








        
      </div>
    </footer>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  













  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>



<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: true,
    notify: true,
    appId: 'iWuakuHkkRt5xT7Ct9cyj8nO-gzGzoHsz',
    appKey: 'PAz23pDzHnucqRDkVMShMp5B',
    placeholder: '(๑•̀ㅁ•́ฅ✧ 说点什么吧！',
    avatar: '',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
